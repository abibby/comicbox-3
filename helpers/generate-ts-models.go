package main

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"regexp"
	"sort"
	"strings"

	"github.com/abibby/comicbox-3/models"
	"github.com/abibby/comicbox-3/server/controllers"
	"github.com/abibby/comicbox-3/server/metadata"
	"github.com/abibby/salusa/database/builder"
)

var types = map[string]string{
	"UUID":            "string",
	"NullUUID":        "string | null",
	"MetadataID":      "string",
	"MetadataService": "string",
	"Time":            "string",
	"string":          "string",
	"Float64":         "number",
	"float64":         "number",
	"Int":             "number",
	"int":             "number",
	"int64":           "number",
	"String":          "string",
	"bool":            "boolean",
	"Bool":            "boolean",
}

func main() {
	m := []interface{}{
		models.Book{},
		models.Page{},
		models.Series{},
		models.User{},
		models.UserBook{},
		models.UserSeries{},
		metadata.Staff{},
		metadata.SeriesMetadata{},
		metadata.DistanceMetadata{},
		controllers.UserSeriesUpdateRequest{},
		controllers.UserBookUpdateRequest{},
		controllers.BookUpdateRequest{},
		controllers.SeriesUpdateRequest{},
		controllers.PageUpdate{},
	}
	enums := []models.Enum{
		models.PageType(""),
		models.List(""),
		controllers.SeriesOrder(""),
		metadata.StaffRole(""),
	}
	ts := "// This file is autogenerated do not edit it\n/* eslint-disable */\n\n"
	for _, model := range m {
		ts += generateTsInterface(model)
	}
	for _, model := range enums {
		ts += generateTsEnum(model)
	}

	err := os.WriteFile("./ui/src/models.ts", []byte(ts), 0644)
	if err != nil {
		panic(err)
	}
}

func generateTsInterface(model interface{}) string {
	t := reflect.TypeOf(model)

	ts := "export interface " + t.Name() + " {"
	ts += generateTsInterfaceProps(t)
	return ts + "\n}\n"
}

func generateTsInterfaceProps(t reflect.Type) string {
	ts := ""
	for i := range t.NumField() {
		sf := t.Field(i)
		if sf.Anonymous {
			ts += generateTsInterfaceProps(sf.Type)
			continue
		}
		if !sf.IsExported() {
			continue
		}
		name, ok := sf.Tag.Lookup("json")
		if !ok {
			continue
		}
		if name == "-" {
			continue
		}
		ts += "\n    " + name + ": " + generateTsType(sf.Type, true)
	}
	return ts
}

func generateTsType(t reflect.Type, allowNull bool) string {
	tsType, ok := types[t.Name()]
	if ok {
		return tsType
	}
	if t.Kind() == reflect.Slice {
		return "Array<" + generateTsType(t.Elem(), false) + ">"
	}
	if t.Kind() == reflect.Map {
		return fmt.Sprintf("Record<%s, %s>", generateTsType(t.Key(), false), generateTsType(t.Elem(), false))
	}

	suffix := ""
	if allowNull {
		suffix = " | null"
	}

	if t.Implements(reflect.TypeOf((*builder.Relationship)(nil)).Elem()) {
		return generateRelationType(t) + suffix
	}

	if t.Name() == "" {
		return generateTsType(t.Elem(), false) + suffix
	}
	return t.Name()
}

func generateRelationType(t reflect.Type) string {
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	for i := range t.NumField() {
		f := t.Field(i)
		if f.Anonymous && f.Name == "relationValue" {
			matches := regexp.MustCompile(`[^[]+\[(\[\])?.+\.([A-Za-z]+)\]`).FindStringSubmatch(t.Field(i).Type.Name())
			return matches[2] + matches[1]
		}
	}
	return ""
}

func generateTsEnum(model models.Enum) string {
	t := reflect.TypeOf(model)

	optionLines := []string{}

	for name, value := range model.Options() {
		b, err := json.Marshal(value)
		if err != nil {
			panic(err)
		}
		optionLines = append(optionLines, "\n    "+name+" = "+string(b)+",")
	}

	sort.Strings(optionLines)

	return "export enum " + t.Name() + " {" +
		strings.Join(optionLines, "") +
		"\n}\n"
}
